from __future__ import annotations

import sys
from pathlib import Path
from typing import Dict, List, Optional

from PyQt6 import QtCore, QtGui, QtWidgets
from googleapiclient import errors

from ..config import ConfigManager, Settings
from ..services import CreatedEvent, EnhancedCreatedEvent, GoogleApi
from ..validation import (
    ScheduleRequest,
    UndoBatch,
    build_schedule,
    parse_date,
    parse_time,
    validate_request,
)
from ..workers import EventCreationWorker, UndoWorker
from ..undo_manager import UndoManager
from .datepicker import DatePicker


class MainWindow(QtWidgets.QMainWindow):
    def __init__(
        self,
        api: GoogleApi,
        config: ConfigManager,
        parent: Optional[QtWidgets.QWidget] = None,
    ) -> None:
        super().__init__(parent)
        self.api = api
        self.config_manager = config
        self.undo_manager = UndoManager(self)
        self.created_events: list[EnhancedCreatedEvent] = []
        self.creation_thread: Optional[QtCore.QThread] = None
        self.undo_thread: Optional[QtCore.QThread] = None
        self.creation_worker: Optional[EventCreationWorker] = None
        self.undo_worker: Optional[UndoWorker] = None

        # Connect undo manager signals
        self.undo_manager.history_changed.connect(self._update_undo_ui)

        self.setWindowTitle("Vacation Calendar Updater")
        self._init_services()
        self.settings = self.config_manager.ensure_defaults(
            default_email=self.user_email,
            calendar_options=self.calendar_names,
        )
        self._build_ui()
        self._setup_status_bar()
        self._apply_settings()
        self._update_validation()

    def _init_services(self) -> None:
        try:
            self.user_email = self.api.user_email()
            self.calendar_names, self.calendar_items = self.api.list_calendars()
        except Exception as exc:  # noqa: BLE001
            QtWidgets.QMessageBox.critical(self, "Unable to connect", str(exc))
            sys.exit(1)
        self.calendar_id_by_name: Dict[str, str] = {}
        for item in self.calendar_items:
            summary = item.get("summary")
            cal_id = item.get("id")
            if summary and cal_id:
                self.calendar_id_by_name[summary] = cal_id
        if not self.calendar_names:
            QtWidgets.QMessageBox.critical(
                self, "No calendars", "No calendars available for this account."
            )
            sys.exit(1)

    def _build_ui(self) -> None:
        central = QtWidgets.QWidget()
        layout = QtWidgets.QGridLayout()
        central.setLayout(layout)

        # Row 0
        layout.addWidget(QtWidgets.QLabel("Event Name"), 0, 0)
        self.event_name = QtWidgets.QLineEdit()
        layout.addWidget(self.event_name, 0, 1)

        layout.addWidget(QtWidgets.QLabel("Notification Email"), 0, 2)
        self.notification_email = QtWidgets.QLineEdit()
        layout.addWidget(self.notification_email, 0, 3)

        # Row 1
        layout.addWidget(QtWidgets.QLabel("Start Date"), 1, 0)
        self.start_date = DatePicker()
        layout.addWidget(self.start_date, 1, 1)

        layout.addWidget(QtWidgets.QLabel("Start Time"), 1, 2)
        self.start_time = QtWidgets.QTimeEdit()
        self.start_time.setDisplayFormat("HH:mm")
        self.start_time.setMinimumWidth(90)
        self._build_time_picker(layout)

        # Row 2
        layout.addWidget(QtWidgets.QLabel("End Date"), 2, 0)
        self.end_date = DatePicker()
        layout.addWidget(self.end_date, 2, 1)

        layout.addWidget(QtWidgets.QLabel("Day Length"), 2, 2)
        self.day_length = QtWidgets.QTimeEdit()
        self.day_length.setDisplayFormat("HH:mm")
        self.day_length.setMaximumWidth(90)
        self.day_length.setTime(QtCore.QTime(8, 0))
        self.day_length.setToolTip("Length of each day (HH:mm)")
        layout.addWidget(self.day_length, 2, 3)

        # Row 3 Weekdays
        self.weekday_boxes: Dict[str, QtWidgets.QCheckBox] = {}
        weekday_frame = QtWidgets.QFrame()
        weekday_layout = QtWidgets.QHBoxLayout()
        weekday_frame.setLayout(weekday_layout)
        for key, label in (
            ("monday", "MO"),
            ("tuesday", "TU"),
            ("wednesday", "WE"),
            ("thursday", "TH"),
            ("friday", "FR"),
            ("saturday", "SA"),
            ("sunday", "SU"),
        ):
            box = QtWidgets.QCheckBox(label)
            self.weekday_boxes[key] = box
            weekday_layout.addWidget(box)
        layout.addWidget(weekday_frame, 3, 0, 1, 2)

        self.days_label = QtWidgets.QLabel("check settings")
        layout.addWidget(self.days_label, 3, 2, 1, 2)

        # Row 4 calendar select + buttons
        self.process_button = QtWidgets.QPushButton("Insert Into Calendar")
        self.process_button.clicked.connect(self._process)
        layout.addWidget(self.process_button, 4, 0, 1, 2)

        self.undo_button = QtWidgets.QPushButton("Undo")
        self.undo_button.clicked.connect(self._undo)
        layout.addWidget(self.undo_button, 4, 2, 1, 1)

        self.send_email_checkbox = QtWidgets.QCheckBox("Send notification email")
        layout.addWidget(self.send_email_checkbox, 4, 3, 1, 1)

        self.calendar_combo = QtWidgets.QComboBox()
        self.calendar_combo.addItems(self.calendar_names)
        layout.addWidget(self.calendar_combo, 5, 0, 1, 4)

        # Log area
        self.log_box = QtWidgets.QPlainTextEdit()
        self.log_box.setReadOnly(True)
        layout.addWidget(self.log_box, 6, 0, 1, 4)

        self.setCentralWidget(central)

        for widget in (
            self.event_name,
            self.notification_email,
            self.start_date,
            self.end_date,
            self.start_time,
            self.day_length,
            *self.weekday_boxes.values(),
            self.calendar_combo,
            self.send_email_checkbox,
        ):
            if isinstance(widget, DatePicker):
                widget.dateChanged.connect(self._on_date_changed)
            elif isinstance(widget, QtWidgets.QAbstractButton):
                widget.toggled.connect(self._update_validation)
            elif isinstance(widget, QtWidgets.QLineEdit):
                widget.textChanged.connect(self._update_validation)
            elif isinstance(widget, QtWidgets.QTimeEdit):
                widget.timeChanged.connect(self._update_validation)
            elif isinstance(widget, QtWidgets.QTimeEdit):
                widget.timeChanged.connect(self._update_validation)
            elif isinstance(widget, QtWidgets.QComboBox):
                widget.currentIndexChanged.connect(self._update_validation)

    def _setup_status_bar(self) -> None:
        """Set up the status bar with progress indicator and permanent widgets."""
        status_bar = self.statusBar()

        # Progress bar for operations
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setVisible(False)  # Hide by default
        self.progress_bar.setMaximumWidth(200)
        status_bar.addPermanentWidget(self.progress_bar)

        # Permanent status widget for undo history
        self.undo_status_label = QtWidgets.QLabel("No undo history")
        self.undo_status_label.setToolTip(
            "Shows the number of batches available to undo"
        )
        status_bar.addPermanentWidget(self.undo_status_label)

        # Initial status message
        status_bar.showMessage("Ready")

    def _apply_settings(self) -> None:
        self.notification_email.setText(self.settings.email_address)
        self.event_name.setText("")
        self.start_time.setTime(QtCore.QTime.fromString("0800", "HHmm"))
        self.day_length.setTime(QtCore.QTime(8, 0))
        self.send_email_checkbox.setChecked(self.settings.send_email)

        for key, box in self.weekday_boxes.items():
            box.setChecked(self.settings.weekdays.get(key, True))

        # set dates default to today
        today = QtCore.QDate.currentDate()
        self.start_date.setDate(today)
        self.end_date.setDate(today)

        # calendar selection
        index = (
            max(0, self.calendar_names.index(self.settings.calendar))
            if self.settings.calendar in self.calendar_names
            else 0
        )
        self.calendar_combo.setCurrentIndex(index)

        self.undo_button.setEnabled(False)

    def _on_date_changed(self, _qdate: QtCore.QDate) -> None:
        """Keep start/end dates in chronological order when either changes."""
        start = self.start_date.date()
        end = self.end_date.date()
        # Normalize: if start > end, pull end forward; if end < start, push start back
        if start.isValid() and end.isValid():
            if start > end:
                # Update end to match start
                self.end_date.blockSignals(True)
                self.end_date.setDate(start)
                self.end_date.blockSignals(False)
                end = start
            elif end < start:
                self.start_date.blockSignals(True)
                self.start_date.setDate(end)
                self.start_date.blockSignals(False)
                start = end
        self._update_validation()

    def _build_time_picker(self, layout: QtWidgets.QGridLayout) -> None:
        """Add a time edit with a drop-down of common times."""

        container = QtWidgets.QWidget()
        hbox = QtWidgets.QHBoxLayout()
        hbox.setContentsMargins(0, 0, 0, 0)
        hbox.setSpacing(4)
        container.setLayout(hbox)

        time_button = QtWidgets.QToolButton()
        icon = self.style().standardIcon(
            QtWidgets.QStyle.StandardPixmap.SP_BrowserReload
        )
        if icon.isNull():
            time_button.setText("â‹¯")
        else:
            time_button.setIcon(icon)
        time_button.setToolTip("Pick a common start time")
        time_button.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)

        menu = QtWidgets.QMenu(time_button)
        self._populate_time_menu(menu)
        time_button.setMenu(menu)

        hbox.addWidget(self.start_time)
        hbox.addWidget(time_button)

        layout.addWidget(container, 1, 3)

    def _populate_time_menu(self, menu: QtWidgets.QMenu) -> None:
        menu.clear()
        for hour in range(6, 20):  # 06:00 to 19:45
            for minute in (0, 15, 30, 45):
                t = QtCore.QTime(hour, minute)
                action = menu.addAction(t.toString("HH:mm"))
                action.triggered.connect(
                    lambda checked=False, tt=t: self.start_time.setTime(tt)
                )

    def _current_weekdays(self) -> dict[str, bool]:
        return {key: box.isChecked() for key, box in self.weekday_boxes.items()}

    def _collect_request(self) -> Optional[ScheduleRequest]:
        try:
            start_date = parse_date(self.start_date.date())
            end_date = parse_date(self.end_date.date())
            start_time = parse_time(self.start_time.time())
        except Exception:
            return None
        day_len_qtime = self.day_length.time()
        day_length_hours = day_len_qtime.hour() + (day_len_qtime.minute() / 60.0)

        return ScheduleRequest(
            event_name=self.event_name.text(),
            notification_email=self.notification_email.text(),
            calendar_name=self.calendar_combo.currentText(),
            start_date=start_date,
            end_date=end_date,
            start_time=start_time,
            day_length_hours=day_length_hours,
            weekdays=self._current_weekdays(),
            send_email=self.send_email_checkbox.isChecked(),
        )

    def _update_validation(self) -> None:
        request = self._collect_request()
        errors: List[str] = []
        if request:
            errors = validate_request(request)
        else:
            errors = ["Complete required fields"]

        if not errors and request:
            schedule = build_schedule(request)
            days = len(schedule)
            hours = days * request.day_length_hours
            self.days_label.setText(f"{days} days ({hours:.2f} hours)")
        else:
            self.days_label.setText("check settings")

        self.process_button.setEnabled(
            len(errors) == 0 and not self._creation_running()
        )
        self.undo_button.setEnabled(
            self.undo_manager.can_undo()
            and not self._creation_running()
            and not self._undo_running()
        )

        # save config opportunistically when valid
        if request and not errors:
            self._save_settings(request)

    def _save_settings(self, request: ScheduleRequest) -> None:
        settings = Settings(
            email_address=request.notification_email,
            calendar=request.calendar_name,
            weekdays=self._current_weekdays(),
            send_email=request.send_email,
        )
        self.settings = settings
        self.config_manager.save(settings)

    def _process(self) -> None:
        if self._creation_running():
            if self.creation_worker:
                self.creation_worker.stop()
            return

        request = self._collect_request()
        if not request:
            QtWidgets.QMessageBox.warning(
                self, "Invalid input", "Please correct the highlighted errors."
            )
            return
        errors_list = validate_request(request)
        if errors_list:
            QtWidgets.QMessageBox.warning(self, "Invalid input", "\n".join(errors_list))
            return
        calendar_id = self.calendar_id_by_name.get(request.calendar_name)
        if not calendar_id:
            QtWidgets.QMessageBox.critical(
                self, "Calendar missing", "Selected calendar ID could not be found."
            )
            return

        self.creation_thread = QtCore.QThread()
        self.creation_worker = EventCreationWorker(self.api, calendar_id, request)
        self.creation_worker.moveToThread(self.creation_thread)
        self.creation_thread.started.connect(self.creation_worker.run)
        self.creation_worker.progress.connect(self._on_creation_progress)
        self.creation_worker.error.connect(self._on_creation_error)
        self.creation_worker.finished.connect(self._on_creation_finished)
        self.creation_worker.stopped.connect(self._on_creation_stopped)
        self.creation_worker.finished.connect(self.creation_thread.quit)
        self.creation_worker.stopped.connect(self.creation_thread.quit)
        self.creation_thread.finished.connect(self.creation_thread.deleteLater)

        self.process_button.setText("Stop Processing")
        self.process_button.setEnabled(True)
        self.undo_button.setEnabled(False)
        self._toggle_inputs(False)
        
        # Show progress bar
        request = self._collect_request()
        if request:
            schedule = build_schedule(request)
            self._show_progress(len(schedule))
        else:
            self._show_progress(0)
        
        self.creation_thread.start()

    def _on_creation_progress(self, message: str) -> None:
        """Handle progress updates from event creation worker."""
        # Update progress bar (approximate progress based on messages)
        current_value = self.progress_bar.value()
        if current_value < self.progress_bar.maximum():
            self._update_progress(current_value + 1)
        
        # Show status message
        self._show_status(message, 3000)  # Show for 3 seconds
        
        # Also append to log for detailed tracking
        self._append_log(message)

    def _on_creation_error(self, message: str) -> None:
        self._append_log(f"Error: {message}")
        QtWidgets.QMessageBox.critical(self, "Error", message)
        self._reset_creation_state()

    def _on_creation_finished(self, events: list[EnhancedCreatedEvent]) -> None:
        self.created_events = events
        description = (
            f"{len(events)} events: {events[0].event_name if events else 'Unknown'}"
        )
        self.undo_manager.add_batch(events, description)
        self._append_log(f"Done. Created {len(events)} events.")
        self._reset_creation_state()
        self._update_undo_ui()

    def _on_creation_stopped(self) -> None:
        self._append_log("Processing stopped.")
        self._reset_creation_state()

    def _undo(self) -> None:
        """Undo the most recent batch of events."""
        recent_batch = self.undo_manager.get_most_recent_batch()
        if not recent_batch or self._undo_running():
            return

        # Get events to undo from the most recent batch
        events_to_undo = recent_batch.events

        self.undo_thread = QtCore.QThread()
        self.undo_worker = UndoWorker(
            self.api,
            events_to_undo,
            send_email=self.send_email_checkbox.isChecked(),
            notification_email=self.notification_email.text(),
            batch_description=recent_batch.description,
        )
        self.undo_worker.moveToThread(self.undo_thread)
        self.undo_thread.started.connect(self.undo_worker.run)
        self.undo_worker.progress.connect(self._append_log)
        self.undo_worker.error.connect(self._on_undo_error)
        self.undo_worker.finished.connect(self._on_undo_finished)
        self.undo_worker.finished.connect(self.undo_thread.quit)
        self.undo_thread.finished.connect(self.undo_thread.deleteLater)

        self.undo_button.setEnabled(False)
        self._toggle_inputs(False)
        self.undo_thread.start()

    def _on_undo_finished(self, deleted_event_ids: list[str]) -> None:
        self._append_log(f"Undo complete. Deleted {len(deleted_event_ids)} events.")

        # Mark the batch as undone in undo manager
        recent_batch = self.undo_manager.get_most_recent_batch()
        if recent_batch:
            self.undo_manager.undo_batch(recent_batch.batch_id)

        self.created_events = []
        self._stop_thread(self.undo_thread, self.undo_worker)
        self._toggle_inputs(True)
        self._update_validation()
        self._update_undo_ui()

    def _on_undo_error(self, message: str) -> None:
        self._append_log(f"Undo error: {message}")
        QtWidgets.QMessageBox.critical(self, "Undo error", message)
        self._stop_thread(self.undo_thread, self.undo_worker)
        self._toggle_inputs(True)
        self._update_validation()

    def _append_log(self, message: str) -> None:
        self.log_box.appendPlainText(message)
        self.log_box.verticalScrollBar().setValue(
            self.log_box.verticalScrollBar().maximum()
        )

    def _reset_creation_state(self) -> None:
        self._toggle_inputs(True)
        self.process_button.setText("Insert Into Calendar")
        self._stop_thread(self.creation_thread, self.creation_worker)
        self.creation_worker = None
        self.creation_thread = None
        self._update_validation()

    def _toggle_inputs(self, enabled: bool) -> None:
        for widget in (
            self.event_name,
            self.notification_email,
            self.start_date,
            self.end_date,
            self.start_time,
            self.day_length,
            self.calendar_combo,
            self.send_email_checkbox,
            *self.weekday_boxes.values(),
        ):
            widget.setEnabled(enabled)

    def _creation_running(self) -> bool:
        return bool(self.creation_thread and self.creation_thread.isRunning())

    def _undo_running(self) -> bool:
        return bool(self.undo_thread and self.undo_thread.isRunning())

    def _stop_thread(
        self, thread: Optional[QtCore.QThread], worker: Optional[object]
    ) -> None:
        if thread and thread.isRunning():
            stop_fn = getattr(worker, "stop", None)
            if callable(stop_fn):
                stop_fn()
            thread.quit()
            thread.wait(3000)

def _update_undo_ui(self) -> None:
        """Update undo-related UI elements based on current undo state."""
        can_undo = self.undo_manager.can_undo()
        self.undo_button.setEnabled(can_undo and not self._creation_running() and not self._undo_running())
        
        # Update undo button text to show recent batch info
        recent_batch = self.undo_manager.get_most_recent_batch()
        if recent_batch:
            self.undo_button.setToolTip(f"Undo: {recent_batch.description}")
        else:
            self.undo_button.setToolTip("No events to undo")
        
        # Update status bar undo info
        stats = self.undo_manager.get_history_stats()
        undoable_batches = stats["undoable_batches"]
        undoable_events = stats["undoable_events"]
        self.undo_status_label.setText(f"{undoable_batches} batches ({undoable_events} events) to undo")

    def _show_progress(self, maximum: int = 100) -> None:
        """Show and initialize the progress bar."""
        self.progress_bar.setMaximum(maximum)
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        self.statusBar().showMessage("Processing...")

    def _update_progress(self, value: int) -> None:
        """Update the progress bar value."""
        self.progress_bar.setValue(value)

    def _hide_progress(self) -> None:
        """Hide the progress bar and clear status."""
        self.progress_bar.setVisible(False)
        self.statusBar().showMessage("Ready")

    def _show_status(self, message: str, timeout: int = 0) -> None:
        """Show a temporary status message."""
        self.statusBar().showMessage(message, timeout)

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:  # type: ignore[override]
        """Gracefully stop worker threads before the window closes."""

        self._stop_thread(self.creation_thread, self.creation_worker)
        self._stop_thread(self.undo_thread, self.undo_worker)

        super().closeEvent(event)


def launch() -> None:
    app = QtWidgets.QApplication(sys.argv)
    api = GoogleApi()
    config = ConfigManager()
    window = MainWindow(api, config)
    window.show()
    sys.exit(app.exec())
